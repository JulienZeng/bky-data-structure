# 1  
```
Lever[0]='\0';
if(T==NULL)
  return;
SqQueue Q;
InitQueue(Q);
EnQueue(Q,T);
int k=0;
while(!QueueEmpty(Q)) {
  T=Q.base[Q.front];
  if (T->lchild!=NULL)
    EnQueue(Q,T->lchild);
  if (T->rchild!=NULL)
    EnQueue(Q,T->rchild);
  DeQueue(Q,T);
  Lever[k++]=T->data;
}
Lever[k]='\0';
```

# 2
```
 int BiTreeDepth(BiTree T)
 { // 初始条件：二叉树T存在。操作结果：返回T的深度
  /*********Begin**********/ 
	if (T==NULL) {
		return 0;
	}
	else {
		int depth=0;
		int m=BiTreeDepth(T->lchild);
		int n=BiTreeDepth(T->rchild);
		if (m>n) {
			return(m+1);
		}
		else {
			return(n+1);
		}
	}
   /**********  End  **********/ 
 }
 ```

# 3  
```
void CreateBiTree(BiTree &T,char s[])
{	
	//s存储了按先序次序遍历二叉树结点值构成的序列（序列中元素为'#'时，表示该结点为空），
	//利用s创建二叉链表表示的二叉树T
   /**********Begin**********/
	char ch;
	ch=s[I++];
	if (ch=='#'){
		T=NULL;
	}
	else {
		T=new BiTNode;
		T->data=ch;
		CreateBiTree(T->lchild,s);
		CreateBiTree(T->rchild,s);
	}
	 /**********  End  **********/	
```
